This file contains old code kept for reference:

#ifndef _MKTSNAPSHOT_H_INCLUDED_
#define _MKTSNAPSHOT_H_INCLUDED_

#include <iostream>
#include <fstream>
#include <string>
#include <vector>


class Price
{
public:
//time:
	std::string m_str_dtLong;	//date/time in long format - eg Tue 24 Nov 15 15:52:37 -0700
	std::string m_str_dtnumber;	//date/time as an int eg 1448380352
	std::string m_str_timems;	//time in h m and milisecond eg 7h45m9962
//prices as string:
	std::string m_str_name;		//name of instrument eg SPY
	std::string m_str_bidPr;	//bid price as string
	std::string m_str_askPr;	//ask price as string
	std::string m_str_bidVol;	//bid volume as string
	std::string m_str_askVol;	//ask volume as string
//prices as long:
	long  m_long_bidPr;	//bid price as long
	long m_long_askPr;	//ask price as long
	long m_long_bidVol;	//bid volume as long
	long m_long_askVol;	//ask volume as long

	bool m_flag_is_realdata;	
	//flag - if false this class has been initialized but not filled with real market data
	//for use when Price class will be used as part of MktSnap or other class - as part of a bigger array
	//set this to true after filling in with real data as opposed to dummy data represented by -1 in constructor
	
	//constructor:
	Price()
	{
		m_str_name = "";	//name of instrument eg SPY
		m_str_bidPr = "";	//bid price as string
		m_str_askPr = "";	//ask price as string
		m_str_bidVol = "";	//bid volume as string
		m_str_askVol = "";	//ask volume as string

		m_long_bidPr = -1;	//bid price as long
		m_long_askPr = -1;	//ask price as long
		m_long_bidVol = -1;	//bid volume as long
		m_long_askVol = -1;	//ask volume as long

		m_flag_is_realdata = 0;
	}

	//member functions:
	void changeStringToLongs()
	{
		//TO DO - write a function that attempts to convert string data to long data using atol function (similar to atoi)
	}
};

class MktSnap	//Snapshot of Mkt at given timepoint. Put these in a vector to have a stream of market data.
{
public:
	std::string m_str_dtLong;	//date/time in long format - eg Tue 24 Nov 15 15:52:37 -0700
	std::string m_str_dtnumber;	//date/time as an int eg 1448380352
	std::string m_str_timems;	//time in h m and milisecond eg 7h45m9962

	//Price m_prices[6];	-- this was the original way of doing it. replaced with vector below:
	std::vector <Price> m_prices;	//array to hold Prices - modify to make bigger if ever needed
									//use: EUR - 0, GBP - 1, SPY - 2, DIA - 3, IWM - 4, QQQ - 5
	MktSnap() {
		m_prices.resize(6);			//increase this if adding anything else - but will need to change
									//void Data::MktSnapshot to put values inside it too
	}
	
};

class StreamOfMktSnap
{
public:
	std::vector<MktSnap> *MktStream;

	//constructor:
	StreamOfMktSnap()
	{
		MktStream = new std::vector<MktSnap>;
	}
};


#endif //_MKTSNAPSHOT_H_INCLUDED_



//
////below function loads prices stored in a file to memory
//void Data::MktSnapshot(/*std::vector<MktSnap> & data*/) //this function loads prices stored in a file to memory
//{
//	/*
//	getline(where to store the extracted characters, how many characters should be taken unlles, seperator(delimiter)) - extracts seperators and delete it
//	get(where to store the extracted characters, how many characters should be taken unlles, seperator(delimiter)) - doesn't extract seperator
//	ignore(how_many_characters_to_extracte AND TO IGNORE THEM, seperator) - extracts characters
//
//	get();
//	*/
//
//	using namespace std;
//
//	Price tempPrice;	//for feeding into tempSnap
//	MktSnap tempSnap;	//temporary object for feeding the ptr_to_vector vector
//	long progressCtr = 0;	//used for displaying how much of file has been processed
//
//
//	//this is where we store the data - histSavedData is part of Data class
//	vector<MktSnap> * ptr_to_vector = &histSavedData;
//
//	//file name from which to input data:
//	fstream file;
//	file.open("sample2.txt", ios::in | ios::binary);
//
//	if (file.is_open())	//load contents of file into vector<MktSnap> * ptr_to_vector = &histSavedData
//	{
//		//std::string scrnoutput;
//		char buf;
//		char temp;
//		string output = "";
//		int counter = 0;	//for the case/switch part
//
//		do {
//			temp = file.get();
//			if ((temp != ',') && (temp != '\n'))
//			{
//				buf = temp;
//				output += buf;	//adds the character buf to string output
//			}
//			if ((temp == ','))
//			{
//				//here - take the output. figure out where to put it
//				//first three outputs - they go into time. rest as market data
//				//output - this now has the string I want to put somewhere
//				//increase the counter, put output according to counter, then clear output
//				//tempSnap is a tempo
//				switch (counter)
//				{
//
//				case 0:		//first long string time
//					tempSnap.m_str_dtLong = output;
//					break;
//				case 1:		//second integer time
//					tempSnap.m_str_dtnumber = output;
//					break;
//				case 2:		//milisecond time as string
//					tempSnap.m_str_timems = output;
//					break;
//				case 3:		//EUR into m_str_name
//					break;	//this holds only the name of instrument!!
//				case 4:
//					tempSnap.m_prices[0].m_str_bidPr = output;
//					break;
//				case 5:
//					tempSnap.m_prices[0].m_str_askPr = output;
//					break;
//				case 6:
//					tempSnap.m_prices[0].m_str_bidVol = output;
//					break;
//				case 7:
//					tempSnap.m_prices[0].m_str_askVol = output;
//					tempSnap.m_prices[0].m_flag_is_realdata = 1;
//					break;
//				case 8:		//GBP into m_str_name
//					break;
//				case 9:
//					tempSnap.m_prices[1].m_str_bidPr = output;
//					break;
//				case 10:
//					tempSnap.m_prices[1].m_str_askPr = output;
//					break;
//				case 11:
//					tempSnap.m_prices[1].m_str_bidVol = output;
//					break;
//				case 12:
//					tempSnap.m_prices[1].m_str_askVol = output;
//					tempSnap.m_prices[1].m_flag_is_realdata = 1;
//					break;
//				case 13:	//SPY into m_str_name
//					break;
//				case 14:
//					tempSnap.m_prices[2].m_str_bidPr = output;
//					break;
//				case 15:
//					tempSnap.m_prices[2].m_str_askPr = output;
//					break;
//				case 16:
//					tempSnap.m_prices[2].m_str_bidVol = output;
//					break;
//				case 17:
//					tempSnap.m_prices[2].m_str_askVol = output;
//					tempSnap.m_prices[2].m_flag_is_realdata = 1;
//					break;
//				case 18:		//DIA into m_str_name
//					break;
//				case 19:
//					tempSnap.m_prices[3].m_str_bidPr = output;
//					break;
//				case 20:
//					tempSnap.m_prices[3].m_str_askPr = output;
//					break;
//				case 21:
//					tempSnap.m_prices[3].m_str_bidVol = output;
//					break;
//				case 22:
//					tempSnap.m_prices[3].m_str_askVol = output;
//					tempSnap.m_prices[3].m_flag_is_realdata = 1;
//					break;
//				case 23:		//IWM into m_str_name
//					break;
//				case 24:
//					tempSnap.m_prices[4].m_str_bidPr = output;
//					break;
//				case 25:
//					tempSnap.m_prices[4].m_str_askPr = output;
//					break;
//				case 26:
//					tempSnap.m_prices[4].m_str_bidVol = output;
//					break;
//				case 27:
//					tempSnap.m_prices[4].m_str_askVol = output;
//					tempSnap.m_prices[4].m_flag_is_realdata = 1;
//					break;
//				case 28:		//QQQ into m_str_name
//					break;
//				case 29:
//					tempSnap.m_prices[5].m_str_bidPr = output;
//					break;
//				case 30:
//					tempSnap.m_prices[5].m_str_askPr = output;
//					break;
//				case 31:
//					tempSnap.m_prices[5].m_str_bidVol = output;
//					break;
//				case 32:
//					tempSnap.m_prices[5].m_str_askVol = output;
//					tempSnap.m_prices[5].m_flag_is_realdata = 1;
//					break;
//				default:
//					cerr << "error reading file (at comma switch)";
//					break;
//				}
//
//				counter++;
//				output = "";
//				//temp = 0;
//			}
//			if (temp == '\n') {
//				//here - this is the end of line. put everything into the vector
//				//vecMktSnap.push_back(tempSnap);
//				ptr_to_vector->push_back(tempSnap);
//				counter = 0;
//			}
//
//			progressCtr++;	//for displaying progress of loading into memory
//			if (progressCtr % 250000 == 0) { std::cout << endl << progressCtr << endl; }
//		} while (!file.eof());	//stay in loop until end of file is reached
//		cout << endl << endl << endl << endl << "output string follows: " << endl;
//	}
//	else
//	{
//		cout << "The file couldn't be opened properly" << endl;
//	}
//
//	cout << endl << endl << "Contents: " << tempSnap.m_prices[0].m_str_bidVol << endl << tempSnap.m_str_dtLong << endl << tempSnap.m_str_timems;
//
//	//print first ten timestamps for check:
//	//for (int i = 0; i < ((vecMktSnap.size() < 3) ? vecMktSnap.size() : 3); i++)
//	//{
//	//	tempSnap = vecMktSnap[i];
//	//	if (i == 0) { cout << endl << "First: " << tempSnap.m_str_timems << endl; }
//	//	std::cout << endl << tempSnap.m_str_timems << endl;
//	//}
//	////print last timestamp for check:
//	//tempSnap = vecMktSnap[vecMktSnap.size() - 1];
//	//std::cout << endl << "Last: " << tempSnap.m_str_timems;
//	//cout << endl << tempSnap.m_prices[2].m_str_askPr << endl;
//	//cout << endl << tempSnap.m_prices[0].m_str_askPr << endl;
//
//
//	//printout part of data for a check:
//	for (int i = 0; i < (((ptr_to_vector->size()) < 3) ? (ptr_to_vector->size()) : 3); i++)
//	{
//		tempSnap = (*ptr_to_vector)[i];
//		if (i == 0) { cout << endl << "First: " << tempSnap.m_str_timems << endl; }
//		std::cout << endl << tempSnap.m_str_timems << endl;
//	}
//	tempSnap = (*ptr_to_vector)[(*ptr_to_vector).size() - 1];
//	cout << endl << " vector output: " << endl;
//	std::cout << endl << "Last: " << tempSnap.m_str_timems;
//	cout << endl << tempSnap.m_prices[2].m_str_askPr << endl;
//	cout << endl << tempSnap.m_prices[0].m_str_askPr << endl;
//
//
//	//function that builds price data in long format from string format
//	for (int i = 0; i < histSavedData.size(); ++i)
//	{
//		for (int j = 0; j < 6; ++j) {
//			//copy and convert prices from string to long format:
//			histSavedData[i].m_prices[j].m_long_askPr = 
//				StringToLong(histSavedData[i].m_prices[j].m_str_askPr);
//			histSavedData[i].m_prices[j].m_long_askVol =
//				StringToLong(histSavedData[i].m_prices[j].m_str_askVol);
//			histSavedData[i].m_prices[j].m_long_bidPr =
//				StringToLong(histSavedData[i].m_prices[j].m_str_bidPr);
//			histSavedData[i].m_prices[j].m_long_bidVol =
//				StringToLong(histSavedData[i].m_prices[j].m_str_bidVol);
//			
//			//set the flag to indicate data is present:			
//			histSavedData[i].m_prices[j].m_flag_is_realdata = true;
//		}
//	}
//}
//
//


//


//                            _____         _                 __                                                            
//   /\ /\  ___   ___  _ __   \_   \ _ __  | |_   ___  _ __  / _|  __ _   ___   ___      ___  _ __   _ __                   
//  / / \ \/ __| / _ \| '__|   / /\/| '_ \ | __| / _ \| '__|| |_  / _` | / __| / _ \    / __|| '_ \ | '_ \                  
//  \ \_/ /\__ \|  __/| |   /\/ /_  | | | || |_ |  __/| |   |  _|| (_| || (__ |  __/ _ | (__ | |_) || |_) |                 
//   \___/ |___/ \___||_|   \____/  |_| |_| \__| \___||_|   |_|   \__,_| \___| \___|(_) \___|| .__/ | .__/                  
//                                                                                           |_|    |_|                     
//          _      _          _      _                       _           _                                          _       
//    ___  | |  __| |   ___  | |  __| |  _ __   _ __   ___  | |_   ___  | |_  _   _  _ __    ___    ___   ___    __| |  ___ 
//   / _ \ | | / _` |  / _ \ | | / _` | | '_ \ | '__| / _ \ | __| / _ \ | __|| | | || '_ \  / _ \  / __| / _ \  / _` | / _ \
//  | (_) || || (_| | | (_) || || (_| | | |_) || |   | (_) || |_ | (_) || |_ | |_| || |_) ||  __/ | (__ | (_) || (_| ||  __/
//   \___/ |_| \__,_|  \___/ |_| \__,_| | .__/ |_|    \___/  \__| \___/  \__| \__, || .__/  \___|  \___| \___/  \__,_| \___|
//                                      |_|                                   |___/ |_|                                     

//old callback kept for reference:
//void UserInterface::experimental_cb(Fl_Widget *w, void * p)
//{
//	using namespace std;
//	cout << "experimental called!" << endl;
//	UserInterface * myInterface = (UserInterface*)p;
//	WidgetTable * myTable = myInterface->GetTable();
//	
//	//	WidgetTable * myTable =(WidgetTable*) p;
//
//	std::string trythis = "mess";
//	int row = 25;
//	int col = 7;
//
//	myTable->printInTable(row, col, trythis/*, myTable*/);
//	myInterface->GetControl()->printCurrentAll();
//}









//BELOW IS OLD CODE KEPT FOR FUTURE REFERENCE:


//void UserInterface::rePriceWidTable(Fl_Widget *w, void*p)	
////THIS FUNCTION HAS BEEN MOVED FROM USERINTERFACE TO CONTROL
////UNDER CONSTRUCTION
////Updates prices displayed in WidgetTable to between 100 above and below
////current bid price in Data class
////Updates slider in UserInterface to current Bid price
//{
//	MikeSimulator * mikesimulator = (MikeSimulator*)p;
//
//	UserInterface* pUI = mikesimulator->GetDisplay()->GetUInterface();
//
//	WidgetTable * pTable = pUI->GetTable();
//
//	//BELOW CODE SET NEW SIZE OF WIDGETTABLE:
//
//	//pTable->clear();
//
//	//first - make sure that the TopRowPrice is set to 100 above current bid price:
//	//Data * myData = mikesimulator->GetData();
//	pTable->SetTopRowPrice(mikesimulator->GetData()->GetBidPrice() + 100);
//	//draw the new widget table:
//	//pTable->SetSize(pTable->GetRows(), pTable->GetCols(), pTable);	//this needs to be called to construct all the cells of WidgetTable																					
//																		//pUI->SetTable(pTable);
//	pUI->m_window1->hide();
//	pUI->m_window1->redraw();
//	pUI->m_window1->show();
//
//	//populate price column with prices:
//	mikesimulator->GetDisplay()->GetUInterface()->GetTable()->PopPriceCol(/*mikesimulator->GetDisplay()->GetWindow()->GetTable()*/);
//	//modify slider in UserInterface:
//	//update the slider minimum and maximum settings:
//	//setting initial Slider max/min values to that of bid/ask - offset:
//	pUI->m_slider1->minimum((double)mikesimulator->GetData()->GetBidPrice() + ((pTable->GetRows()) / 2) - 3 /* 3 offset for safety*/);
//	pUI->m_slider1->maximum((double)mikesimulator->GetData()->GetBidPrice() - ((pTable->GetRows()) / 2) + 3 /* 3 offset for safety*/);
//	pUI->m_slider1->value((double)mikesimulator->GetData()->GetBidPrice());
//}
//void UserInterface::rePriceWidTable2(Fl_Widget *w, void*p)	//UNDER CONSTRUCTION
//															//Updates prices displayed in WidgetTable to between 100 above and below
//															//current bid price in Data class
//															//Updates slider in UserInterface to current Bid price
//{
//
//	////this version takes the 'this' pointer instead of MikeSimulator as the void *p parameter
//	////MikeSimulator * mikesimulator = (MikeSimulator*)p;
//	//UserInterface* pUI = (UserInterface*)p;
//
//
//	//WidgetTable * pTable = pUI->GetTable();
//
//	////BELOW CODE SET NEW SIZE OF WIDGETTABLE:
//
//	////pTable->clear();
//
//	////first - make sure that the TopRowPrice is set to 100 above current bid price:
//	////Data * myData = mikesimulator->GetData();
//	//pTable->SetTopRowPrice(pUI->bid_price + 100);
//	////draw the new widget table:
//	////pTable->SetSize(pTable->GetRows(), pTable->GetCols(), pTable);		//this needs to be called to construct all the cells of WidgetTable																					
//	////pUI->SetTable(pTable);
//	//pUI->m_window1->hide();
//	//pUI->m_window1->redraw();
//	//pUI->m_window1->show();
//
//	////populate price column with prices:
//	//pUI->GetTable()->PopPriceCol(/*mikesimulator->GetDisplay()->GetWindow()->GetTable()*/);
//	////modify slider in UserInterface:
//	////update the slider minimum and maximum settings:
//	////setting initial Slider max/min values to that of bid/ask - offset:
//	//pUI->m_slider1->minimum((double)mikesimulator->GetData()->GetBidPrice() + ((pTable->GetRows()) / 2) - 3 /* 3 offset for safety*/);
//	//pUI->m_slider1->maximum((double)mikesimulator->GetData()->GetBidPrice() - ((pTable->GetRows()) / 2) + 3 /* 3 offset for safety*/);
//	//pUI->m_slider1->value((double)mikesimulator->GetData()->GetBidPrice());
//}



//void WidgetTable::draw_cell(TableContext context,
//	int R, int C, int X, int Y, int W, int H)
//{
//	switch (context)
//	{
//	case CONTEXT_STARTPAGE:
//		fl_font(FL_HELVETICA, 12);		// font used by all headers
//		col_width_all(50);				// sets the width of the columns
//		break;
//
//	case CONTEXT_RC_RESIZE:
//	{
//		int X, Y, W, H;
//		int index = 0;
//		for (int r = 0; r<rows(); r++)
//		{
//			for (int c = 0; c<cols(); c++)
//			{
//				if (index >= children()) break;
//				find_cell(CONTEXT_TABLE, r, c, X, Y, W, H);
//				child(index++)->resize(X, Y, W, H);
//			}
//		}
//		init_sizes();			// tell group children resized
//		return;
//	}
//
//	case CONTEXT_ROW_HEADER:
//		fl_push_clip(X, Y, W, H);
//		{
//			static char s[40];
//			sprintf(s, "Row %d", R);
//			fl_draw_box(FL_THIN_UP_BOX, X, Y, W, H, row_header_color());
//			fl_color(FL_BLACK);
//			fl_draw(s, X, Y, W, H, FL_ALIGN_CENTER);
//		}
//		fl_pop_clip();
//		return;
//
//	case CONTEXT_COL_HEADER:
//		fl_push_clip(X, Y, W, H);
//		{
//			static char s[40];
//			//below decide what is printed in column headers:
//			ColHeaderText(s, C);	//this function performs commented out code below
//
//			//if (C == 0)
//			//{
//			//	sprintf(s, "BUY");
//			//}
//			//else
//			//{
//			//	sprintf(s, "Col %d", C);
//			//}
//
//			fl_draw_box(FL_THIN_UP_BOX, X, Y, W, H, col_header_color());
//			fl_color(FL_BLACK);
//			fl_draw(s, X, Y, W, H, FL_ALIGN_CENTER);
//		}
//		fl_pop_clip();
//		return;
//
//	case CONTEXT_CELL:
//		return;		// fltk handles drawing the widgets
//
//	default:
//		return;
//	}
//}

//OLD CODE - JUST TO SHOW LEARNING PROCESS
//void UserInterface::printInTable(int row, int col, std::string text, UserInterface *p)//this causes trouble
//{
//	
//	UserInterface * myInterface = p;
//
//	WidgetTable * myWidgetTable = myInterface->table;
//
//	Fl_Widget * myWidget =  myWidgetTable->GetElement(row, col);
//
//	Fl_Input * myCell = dynamic_cast<Fl_Input*>(myWidget);
//
//	std::stringstream buffer;
//
//	buffer << "try";
////	myCell->value(buffer.str().c_str());
//
//	//myCell->value("try");
//
//	//Fl_Widget * myWidget = mytable->GetElement(row, col);
//	
//	
//	/*Fl_Input * myTargetCell = 
//	mytable->GetElement(row, col);*/
//	
//	
//	//Fl_Input  * targetCell = (Fl_Input*)(table->GetElement(row, col));
//	//std::stringstream buffer;
//	//buffer << text;
//
//	//targetCell->value(buffer.str().c_str());
//	//targetCell->value("400");
//}

//OLD CODE
//void WidgetTable::printInTable(int row, int col, std::string text, UserInterface * myIntPointer)//this causes trouble
//{
//
//	UserInterface * myInterface = myIntPointer;
//
//
//	WidgetTable * myTable = myIntPointer->table;
//
//	//Fl_Widget * myWidget = myTable->GetElement(row, col);
//
//	Fl_Widget * myWidget = static_cast<Fl_Widget*> (myTable->GetVoidElement(row, col));
//
//	//Fl_Input * myCell = static_cast<Fl_Input*>(myWidget);
//
//	Fl_Input * myCell = (Fl_Input*)(myWidget);
//
//	//My_fl_button * myCell = static_cast<My_fl_button*>(myWidget);
//
//	std::stringstream buffer;
//
//	buffer << "try";
//	//myCell->value(buffer.str().c_str());
//
//	//myCell->value("try");
//
//	//Fl_Widget * myWidget = mytable->GetElement(row, col);
//
//
//	/*Fl_Input * myTargetCell =
//	mytable->GetElement(row, col);*/
//
//
//	//Fl_Input  * targetCell = (Fl_Input*)(table->GetElement(row, col));
//	//std::stringstream buffer;
//	//buffer << text;
//
//	//targetCell->value(buffer.str().c_str());
//	//targetCell->value("400");
//
//}

//Fl_Text_Buffer * UserInterface::textBuffer;
//Fl_Text_Display * UserInterface::text;

//void UserInterface::setptr()		//OLD CODE?? DO I STILL NEED THIS?
//{
//	table->ptr_to_UserInterface = this;
//}

//void UserInterface::cb_btn_start_callback(Fl_Widget* btn, void* userdata)
//{
//	UserInterface* window = (UserInterface*)userdata;
//	window->m_window1->label("start"); //set window title
//	window->m_is_animated = true;
//	Fl::add_timeout(/*TIMER_TIMEOUT*/ UserInterface::TIMER_TIMEOUT, timer_event, window);
//}

//void UserInterface::cb_btn_stop_callback(Fl_Widget* btn, void* userdata)
//{
//	UserInterface* window = (UserInterface*)userdata;
//	window->m_is_animated = false;
//	window->m_window1->label("stop");
//}

//void UserInterface::timer_event(void* userdata)
//{
//	UserInterface* window = (UserInterface*)userdata;
//	
//	if (window->m_is_animated)
//	{
//		++window->m_count;
//		std::stringstream buffer;
//		buffer << window->m_count;
//		//buffer.str(); // .str() convert what's in buffer to string
//		//buffer.str().c_str(); // .c_str() converts std::string to char*
//		window->m_window1->label(buffer.str().c_str() );
//		Fl::add_timeout(/*TIMER_TIMEOUT*/1.0, timer_event, window);
//	}
//}

//void UserInterface::m_down_btn_cb(Fl_Widget *w, void * p)
//{
//	//UserInterface * myUserInt = (UserInterface*)p;
//
//
//	//REFACTOR THIS:
//
//	UserInterface * myUserInt = (UserInterface*)p;
//	Data * myData = myUserInt->ptr_to_mikesimulator->GetData();
//	Control * myControl = myUserInt->ptr_to_mikesimulator->GetControl();
//
//	//change bid ask prices:
//	myData->SetPrevAskPrice(myData->GetAskPrice());
//	myData->SetPrevBidPrice(myData->GetBidPrice());
//	myData->SetAskPrice(myData->GetAskPrice() - 1);
////	myData->ask_price--;
//	myData->SetBidPrice(myData->GetBidPrice() - 1);
////	myData->bid_price--;
//	//update slider value:
//	myUserInt->m_slider1->value((double)myData->GetBidPrice());
//	//do something:
//	myControl->MainLoop();
//}

//void UserInterface::m_up_btn_cb(Fl_Widget *w, void * p)
//{
//	UserInterface * myUserInt = (UserInterface*)p;
//	Data * myData = myUserInt->ptr_to_mikesimulator->GetData();
//	Control * myControl = myUserInt->ptr_to_mikesimulator->GetControl();
//
//	//change bid ask prices:
//	if (myUserInt)
//	{
//		myData->SetPrevAskPrice(myData->GetAskPrice());
//		myData->SetPrevBidPrice(myData->GetBidPrice());
//		myData->SetAskPrice(myData->GetAskPrice() + 1);
//		myData->SetBidPrice(myData->GetBidPrice() + 1);
//		std::cout << "price change" << std::endl;
//
//	}
//	else
//	{
//		std::cout << "Missing a pointer" << std::endl;
//	}
//	
//
//
//	//update slider value:
//	myUserInt->m_slider1->value((double)myData->GetBidPrice());
//	//do something:
//	myControl->MainLoop();
//}

//void UserInterface::m_slider1_cb(Fl_Widget *w, void * p)
//{
//	Fl_Value_Slider * mySlider = (Fl_Value_Slider*)w;
//	UserInterface * myUserInt = (UserInterface*)p;
//	Data * myData = myUserInt->ptr_to_mikesimulator->GetData();
//	Control * myControl = myUserInt->ptr_to_mikesimulator->GetControl();
//	double sliderVal = mySlider->value();
//
//	//change bid ask prices:
//	myData->SetPrevAskPrice(myData->GetAskPrice());
//	myData->SetPrevBidPrice(myData->GetBidPrice());
//	long differenceBidAsk;	//preserve bid ask spread
//	differenceBidAsk = myData->GetAskPrice() - myData->GetBidPrice();
//	myData->SetAskPrice((long)sliderVal + differenceBidAsk);
//	myData->SetBidPrice((long)sliderVal);
//	//do something:
//	myControl->MainLoop();
//}

////WIDGETTABLE:
////CONSTRUCTOR:
//WidgetTable::WidgetTable(UserInterface * pUserInterface, int x, int y, int w, int h, const char *l = 0) : Fl_Table_Row(x, y, w, h, l)
//{
//
//	ptr_to_UserInterface = pUserInterface;
//
//	ButtonColsNumber = 5;	//how many columns of buttons?
//	TopRowPrice = 800;
//	table_rows, table_cols = 20;
//
//	col_header(1);
//	col_resize(1);
//	col_header_height(40);
//
//	row_header(1);
//	row_resize(0);
//	row_header_width(40);
//	end();
//
//
//	//col_header(1);
//	//col_resize(0);
//	//col_header_height(20);
//	//row_header(1);
//	//row_resize(0);
//	//row_header_width(30);
//	//end();
//
//
//}
////below fills the table with objects:
//void WidgetTable::SetSize(int newrows, int newcols, WidgetTable * mytable)
//{
//	rows(newrows);
//	cols(newcols);
//	mytable->SetRows(newrows);
//	mytable->SetCols(newcols);
//
//	begin();		// start adding widgets to group
//	{
//		for (int r = 0; r<newrows; r++)
//		{
//			for (int c = 0; c<newcols; c++)
//			{
//				int X, Y, W, H;
//				find_cell(CONTEXT_TABLE, r, c, X, Y, W, H);
//				char s[40];
//				//below decides what is put into table:
//				//r is row and c is col
//				if (c >= mytable->ButtonColsNumber/*c != 0 && c != 1 && c != 2 && c != 3*/) //this used to be ( c & 1) -bitwise comparison				
//				{
//					// Create the input widgets
//					//sprintf(s, "%d/%d", r, c);
//					Fl_Input *in = new Fl_Input(X, Y, W, H);
//					//in->value(s);
//					in->textsize(10);	//sets the size of the font					
//				}
//				else
//				{
//					// Create the light buttons
//					sprintf(s, "%d/%d ", r, c);
//					My_fl_button *butt = new My_fl_button(X, Y, W, H, strdup(s));
//					//Fl_Light_Button *butt = new Fl_Light_Button(X, Y, W, H, strdup(s));
//					butt->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
//					butt->callback(button_cb, (void*)mytable);
//					//butt->value(((r + c * 2) & 4) ? 1 : 0);	//this sets the light on or off for Fl_Light_Button
//					if (c == 0) butt->label("CXL");
//					if (c == 1) butt->label("B LMT");
//					if (c == 2) butt->label("B STP");
//					if (c == 3) butt->label("S LMT");
//					if (c == 4) butt->label("S STP");
//					butt->x_pos = c;	//set the col
//					butt->y_pos = r;	//set the row
//				}
//
//			}
//		}
//	}
//	end();
////below doesnt work:
////	mytable->PopPriceCol(this);
////	PopPriceCol();	//populate price column with prices
//
//}
//void WidgetTable::draw_cell(TableContext context,
//	int R, int C, int X, int Y, int W, int H)
//{
//	switch (context)
//	{
//	case CONTEXT_STARTPAGE:
//		fl_font(FL_HELVETICA, 9);		// font used by all headers
//		col_width_all(55);				// sets the width of the columns
//		row_height_all(18);
//		break;
//
//	case CONTEXT_RC_RESIZE:
//	{
//		int X, Y, W, H;
//		int index = 0;
//		for (int r = 0; r<rows(); r++)
//		{
//			for (int c = 0; c<cols(); c++)
//			{
//				if (index >= children()) break;
//				find_cell(CONTEXT_TABLE, r, c, X, Y, W, H);
//				child(index++)->resize(X, Y, W, H);
//			}
//		}
//		init_sizes();			// tell group children resized
//		return;
//	}
//
//	case CONTEXT_ROW_HEADER:
//		fl_push_clip(X, Y, W, H);
//		{
//			static char s[40];
//			sprintf(s, "%d", TopRowPrice - R);
//			fl_draw_box(FL_THIN_UP_BOX, X, Y, W, H, row_header_color());
//			fl_color(FL_BLACK);
//			fl_draw(s, X, Y, W, H, FL_ALIGN_CENTER);
//		}
//		fl_pop_clip();
//		return;
//
//	case CONTEXT_COL_HEADER:
//		fl_push_clip(X, Y, W, H);
//		{	//set the width of a single column:
//			//this doesnt work :(	
//			//if (C == 1)
//			//{
//			//	col_width(C, 30);
//			//	init_sizes();
//			//	Fl::redraw();
//			//}
//
//			fl_font(FL_HELVETICA, 11);
//			static char s[40];
//			//below decide what is printed in column headers:
//			ColHeaderText(s, C);	//this function performs commented out code below
//
//									//if (C == 0)
//									//{
//									//	sprintf(s, "BUY");
//									//}
//									//else
//									//{
//									//	sprintf(s, "Col %d", C);
//									//}
//
//			fl_draw_box(FL_THIN_UP_BOX, X, Y, W, H, col_header_color());
//			fl_color(FL_BLACK);
//			fl_draw(s, X, Y, W, H, /*FL_ALIGN_CENTER,*/ FL_ALIGN_WRAP);	//modified to use wrap
//		}
//
//		fl_pop_clip();
//		return;
//
//	case CONTEXT_CELL:
//		return;		// fltk handles drawing the widgets
//
//	default:
//		return;
//	}
//}
//void WidgetTable::ColHeaderText(char * s, int C)	//defines text of column headers
//{
//	switch (C)
//	{
//	case 0:
//		sprintf(s, "CANCEL\nORDER");
//		break;
//	case 1:
//		sprintf(s, "BUY");
//		break;
//	case 2:
//		sprintf(s, "BUY");
//		break;
//	case 3:
//		sprintf(s, "SELL");
//		break;
//	case 4:
//		sprintf(s, "SELL");
//		break;
//	case 5:
//		sprintf(s, "PRICE");
//		break;
//	case 6:
//		sprintf(s, "BID");
//		break;
//	case 7:
//		sprintf(s, "ASK");
//		break;
//	case 8:
//		sprintf(s, "ORDER\nSIZE");
//		break;
//	case 9:
//		sprintf(s, "ORDER\nTYPE");
//		break;
//	case 10:
//		sprintf(s, "ORDER\nPRICE");
//		break;
//	case 11:
//		sprintf(s, "OPEN\nPOSITION");
//		break;
//	case 12:
//		sprintf(s, "OPEN\nP/L");
//		break;
//	case 13:
//		sprintf(s, "CLOSED\nP/L");
//		break;
//	case 14:
//		sprintf(s, "TOTAL\nP/L");
//		break;
//	default:
//		sprintf(s, "Col %d", C);
//	}
//	//if (C == 0)
//	//{
//	//	sprintf(s, "BUY");
//	//}
//	//else
//	//{
//	//	sprintf(s, "my %d", C);
//	//}
//}
//My_fl_button::My_fl_button(int x, int y, int w, int h, const char *l = 0)
//	: Fl_Button(x, y, w, h, l), x_pos(0), y_pos(0)
//{
//	x_pos = 0;
//	y_pos = 0;
//}
////CALLBACKS:
//void WidgetTable::button_cb(Fl_Widget *w, void * p)
//{
//	//this callback is set inside the WidgetTable::SetSize function!!
//	My_fl_button * myButton = (My_fl_button*)w;		//myButton is the button that was pressed
//	WidgetTable * thisTable = (WidgetTable*)p;		//thisTable is the table in which the button was pressed
//	UserInterface * myUI = thisTable->GetUserInterface();	//myUI is the UserInterface in which the table is created
//	MikeSimulator * mySimulator = myUI->GetMikeSim();
//
//	//send the information to Control:
//	//What price level was pressed?:
//	int rowPressed = myButton->y_pos;		//this is the row in which the button was pressed
//	long price = thisTable->PriceOfRow(rowPressed);
//	int OrderType = myButton->x_pos;
//	mySimulator->GetControl()->ManualOrder(OrderType, price);	//send the information to Control
//	//below - print out the price corresponding to the row in which the button was pressed:
//
//	
//	//std::cout << "\nRow pressed: " << rowPressed << std::endl;
//	//std::cout << "\nCorresponding price: " << thisTable->PriceOfRow(rowPressed) << std::endl;
//
//
////	std::cout << '\n' << sizeof(long) << " " << sizeof(long long) << " " << sizeof(double);
//
//
//	//OLD CODE:
//	////	fprintf(stderr, "BUTTON: %s\n", (const char*)w->label());
//	//	
//	//	WidgetTable * myTable = static_cast<WidgetTable*>(p);		//WidgetTable * myTable = (WidgetTable*)(p);
//	//	UserInterface * myUserInterface = static_cast<UserInterface*>(myTable->ptr_to_UserInterface);		//UserInterface * myUserInterface = (UserInterface*)(myTable->ptr_to_UserInterface);
//	//	int  myRow = 8, myColumn = 8;
//	//	Fl_Widget * myWidget = myTable->GetElement(myRow, myColumn);
//	//	Fl_Input * myCell = dynamic_cast<Fl_Input*>(myWidget);
//	//
//	//	myWidget = myTable->GetElement(myRow, myColumn);
//	//
//	//	My_fl_button * myFlButton = (My_fl_button*)w;
//	//	//printout the x y positions of the button pressed:
//	//	std::cout << std::endl << myFlButton->x_pos << std::endl;
//	//	std::cout << myFlButton->y_pos << std::endl;
//	//
//	//	myCell = dynamic_cast<Fl_Input*>(myWidget);
//	//
//	//	myCell->value("try");
//	//	myUserInterface->textDisplayString << "button pressed" << std::endl;
//	//	myUserInterface->textBuffer->text((myUserInterface->textDisplayString).str().c_str());
//	//
//	//	myTable->printInTable(6, 6, "text"/*, myTable*/);
//
//}
////HELPLERS:
//void WidgetTable::printInTable(int row, int col, std::string text)//row = 0 is first row!
//{
//	WidgetTable * myTable = this;
//
//	//	WidgetTable * myTable = myWidgetPointer;
//
//	//first, make sure row and col are not bigger than the size of the table:
//
//	//std::cout << myWidgetPointer->rows() << std::endl
//	//	<< myWidgetPointer->table_rows << std::endl 
//	//	<< row;
//
//	if (row >= myTable->GetRows()) {
//		std::cout << "\nPrint attempt in row outside of WidgetTable";
//		row = myTable->GetRows() - 1;
//	}
//	if (col >= myTable->GetCols()) {
//		std::cout << "\nPrint attempt in col outside of WidgetTable";
//		/*myCol*/col = myTable->GetCols() - 1;
//	}
//	if (row < 0) {
//		std::cout << "\nPrint attempt in row outside of WidgetTable";
//		row = 0;
//	}
//	if (col < myTable->ButtonColsNumber) {
//		std::cout << "\nPrint attempt in col outside of WidgetTable";
//		col = myTable->ButtonColsNumber;
//	}
//	//find the cell:
//	Fl_Widget * myWidget = (Fl_Widget*)(myTable->GetElement(row, col));
//	Fl_Input * myCell = (Fl_Input*)(myWidget);
//	//print into the cell:
//	myCell->textsize(12);	//sets the size of the font
//	std::stringstream buffer;
//	buffer << text;
//	myCell->value(buffer.str().c_str());
//}
//Fl_Widget * WidgetTable::GetElement(int nRow, int nCol)	
//{//used to get a pointer to an element of WidgetTable with X Y coordinates nRow nCol
////nRow = 0 -> points to FIRST row; nCol = 0 -> points to col number 1!
////watch for off by one errors
//	int numCol = this->cols();
//	int nIndex = nRow * numCol + nCol;
//	return this->child(nIndex);
//}
//int WidgetTable::RowOfPrice(long price)
//{
//	int rowToReturn = TopRowPrice - price;
//	return rowToReturn;
//}   //given price - returns the row in which that price is displayed in WidgetTable
//long WidgetTable::PriceOfRow(int row)
//{
//	long price = TopRowPrice - row;
//
//	return price;
//}	 //given the row - returns what price is currently printed in that row
//MikeSimulator * WidgetTable::GetMikeSim()
//{
//	return ptr_to_UserInterface->GetMikeSim();
//}
//void WidgetTable::PopPriceCol(/*WidgetTable * myTable*/) //populates the Price column with prices based on current TopRowPrice
//{
//
//		int PriceCol = 5;	//change this as neccessary if design changes made to WidgetTable
//		int PriceToPrint;
//		//print prices in rows from 0 to last
//
//		for (int row = 0; row < table_rows; row++)
//		{
//			PriceToPrint = TopRowPrice - row;
//			Fl_Input * myCell = (Fl_Input*)GetElement(row, PriceCol);
//			char ch[40];
//			sprintf(ch, "%d", PriceToPrint);
//			myCell->value(ch);
//		}
//	
//}
//
//void WidgetTable::PopPriceCol(WidgetTable * myTable) //populates the Price column with prices based on current TopRowPrice
//{
//
//	int PriceCol = 5;	//change this as neccessary if design changes made to WidgetTable
//	int PriceToPrint;
//	//print prices in rows from 0 to last
//
//	for (int row = 0; row < table_rows; row++)
//	{
//		PriceToPrint = TopRowPrice - row;
//		Fl_Input * myCell = (Fl_Input*)GetElement(row, PriceCol);
//		char ch[40];
//		sprintf(ch, "%d", PriceToPrint);
//		myCell->value(ch);
//	}
//
//}













































old MikePositionOrders.cpp:
#include <time.h> //for clock_t, clock, CLOCKS_PER_SEC

#include <vector>
#include <string>
#include <set>
#include <unordered_set>

#include "MikePositionsOrders.h"
#include <iostream>

#include "MikeTimer.h"
#include "MikeOrderbook.h"

#include "PositionBook.h"



MikePositionOrders::MikePositionOrders(std::string name, long highestPrice)
{
//initialize positionbook - the class that stores all positions. How big is the positionBook? This is defined by PositionBookmaxPrice:
	positionbook = new PositionBook(highestPrice);
	
//initialize orderbook with a pointer to this MikePositionOrders:
	orderbook = new MikeOrderbook(this , highestPrice);
//name this MikePositionOrders:
	nameOfBook = name;

	//BELOW TEMPORARY FIX FOR REFACTORING:
	refactoringPositionvector.resize(highestPrice + 1);
	refactorOrdersBP.resize(highestPrice + 1);

}

MikePositionOrders::~MikePositionOrders()
{
	delete positionbook;
	positionbook = NULL;
	delete orderbook;
	orderbook = NULL;
}

void MikePositionOrders::newOrder(MikeOrderType type, long orderPrice, long orderAmount)
{
	orderbook->neworder( type, orderPrice, orderAmount);	
}

void MikePositionOrders::checkFills(long bidPrice, long askPrice)
{
	orderbook->checkfills(bidPrice, askPrice);
}

const std::vector<MikePosition>* MikePositionOrders::GetMikePositions()
{
	return positionbook->GetMikePositions();
//	return nullptr;
}

void MikePositionOrders::fillposition(int posprice, long fillprice, long filledamount, long bidPrice, long askPrice)
{
	positionbook->fillposition( posprice, fillprice, filledamount, bidPrice, askPrice);
}

long MikePositionOrders::CalcAllOpenPL(long bidprice, long askprice)
{

	//using namespace std;
	//static long prevbidprice = 0;
	//static long prevaskprice = 0; //for speed - to calculate only if bid or ask price has changed
	//static long allOpenPL = 0;
	////first - check if bid or ask price has changed:
	//if (bidprice != prevbidprice || askprice != prevaskprice)
	//{
	//	allOpenPL = 0;//allOpenPL is static!
	//	cout << "CalcAllOpenPL called" << endl;
	//	//go through every position in the openPosIndex and calculate each individual position's openPL:
	//	for (long price : openPosIndexSet)
	//	{
	//		positionBook.at(price).calculatePL(bidprice, askprice);
	//		allOpenPL = allOpenPL + positionBook.at(price).open_pl;
	//	}
	//	prevaskprice = askprice;
	//	prevbidprice = bidprice;
	//}

	//cout << "allOpenPL = " << allOpenPL << endl;


	//return allOpenPL;

	return positionbook->CalcAllOpenPL(bidprice, askprice);
}

long MikePositionOrders::CalcAllClosedPL(long bidprice, long askprice)
{
	//static long prevbidprice = 0;
	//static long prevaskprice = 0; //for speed - to calculate only if bid or ask price has changed
	//static long allClosedPL = 0;

	////first - check if bid or ask price has changed:
	//if (bidprice != prevbidprice || askprice != prevaskprice)
	//{
	//	allClosedPL = 0;//allClosedPL is static!

	//				  //go through every position in the openPosIndex and calculate each individual position's openPL:
	//	for (long price : openPosIndexSet)
	//	{
	//		positionBook.at(price).calculatePL(bidprice, askprice);
	//		allClosedPL = allClosedPL + positionBook.at(price).closed_pl;
	//	}
	//	prevaskprice = askprice;
	//	prevbidprice = bidprice;
	//}

	//return allClosedPL;
	return positionbook->CalcAllClosedPL(bidprice, askprice);
}

long MikePositionOrders::CalcAllTotalPL(long bidprice, long askprice)
{
	//static long prevbidprice = 0;
	//static long prevaskprice = 0; //for speed - to calculate only if bid or ask price has changed
	//static long allTotalPL = 0;

	////first - check if bid or ask price has changed:
	//if (bidprice != prevbidprice || askprice != prevaskprice)
	//{
	//	allTotalPL = 0;//allTotalPL is static!

	//	//go through every position in the openPosIndex and calculate each individual position's openPL:
	//	for (long price : openPosIndexSet)
	//	{
	//		positionBook.at(price).calculatePL(bidprice, askprice);
	//		allTotalPL = allTotalPL + positionBook.at(price).total_pl ;
	//	}

	//	////update previous bid/ask prices for future checks:
	//	prevbidprice = bidprice;
	//	prevaskprice = askprice;
	//}

	//return allTotalPL;

	return positionbook->CalcAllTotalPL(bidprice,askprice);
}

long MikePositionOrders::CalcTotalOpenPos()
{
	//
	//long totalOpenPosition = 0; 
	////go through every position in the openPosIndex and add up all the open_amount values:
	//for (long price : openPosIndexSet)
	//{
	//	totalOpenPosition = totalOpenPosition + positionBook.at(price).open_amount;
	//}
	//
	//return totalOpenPosition ;

	return positionbook->CalcTotalOpenPos();
}

void MikePositionOrders::calculateIndividualPLs(long bidprice, long askprice)
{
	//for (long price : openPosIndexSet)
	//{
	//	positionBook.at(price).calculatePL(bidprice, askprice);
	//}
}

void MikePositionOrders::updateOpenOrdersByPrice()
{
	orderbook->updateOpenOrdersByPrice();
}





bool MikeOrdersAtPrice::checkifempty()
{
		if (buyLimitAmount == 0 && buyStopAmount == 0 && sellLimitAmount == 0 && sellStopAmount == 0)
			return true;
		else
			return false;
}

//this for testing purposes only.
void MikePositionOrders::printoutAllOrders()
{
	//using namespace std;
	//cout << "Print orders button pressed. " << endl;
	//MikeOrder temp;
	//for (unsigned int i = 0; i < openOrderBook.size(); ++i)
	//{
	//	temp = openOrderBook[i];
	//	cout << "Order ID: " << temp.orderId << " Order type: " 
	//		<< temp.ordertype << " Order Price: " << temp.price 
	//		<< " Amount: " << temp.amount << endl;
	//}
}

void MikePositionOrders::cancelOrder(long orderId)
{
	using namespace std;
	cout << "Not implemented. Cancel orderId: " << orderId << endl;
}

void MikePositionOrders::cancelAllOrdAtPrice(long price)
{
	using namespace std;
	cout << "Not implemented. Cancelling all orders at price: " << price << endl;
}

const std::vector<MikeOrdersAtPrice>* MikePositionOrders::GetOpOrdersbyPrice()
{
	return orderbook->GetOpOrdersbyPrice();
//	return &orderbook->openOrdersByPrice;   /*return &refactorOrdersBP;*/ /*return &openOrdersByPrice;*/
	
}


void MikePositionOrders::printoutActivePositions(long bidprice, long askprice)
{
	//	using namespace std;
	////	if (openPosIndex.size() == 0)	cout << "\nNo active positions." << endl;
	//	if (openPosIndexSet.size() == 0)	cout << "\nNo active positions." << endl;
	//
	////	Mike::Timer timer;
	//
	//	timer.reset();
	//
	//	/*
	//	Go through all active positions and print them out.
	//	To do this, I require an index that stores only active positions so that I do not need to
	//	iterate through 1000000 positions every time
	//	*/
	//
	////	for (unsigned int i = 0; i < openPosIndex.size(); ++i)
	//	
	//	for (long price : openPosIndexSet)
	//	{
	//
	//		positionBook.at(price).calculatePL(bidprice, askprice);
	//		
	//		//openPosIndex stores the PRICES which have active positions
	//		MikePosition temp = positionBook.at(price);
	//		
	//		cout << 
	//			" Pos price: " << temp.price << 
	//			" size: " << temp.open_amount <<
	//			" Closed PL: " << temp.closed_pl <<
	//			" Open PL: " << temp.open_pl <<
	//			" Total PL: " << temp.total_pl			
	//			<< endl;
	//	}
	//
	//	cout << "All Open PL: " << CalcAllOpenPL(bidprice, askprice) << " All Closed PL: " << CalcAllClosedPL(bidprice, askprice)
	//		<< " All Total PL: " << CalcAllTotalPL(bidprice, askprice) << endl;
	//
	//	//we have changed some positions by calling the calculatePL method.
	//	//so now, lets update the index in case some positions where completely zeroed out:
	////	for (unsigned int i = 0; i < openPosIndex.size(); i++)
	//		for (long price : openPosIndexSet)
	//	{
	//		checkIfStillActive(price);
	//	}
	//
	//
	//	cout << "Printing positions took : " << timer.elapsed() << endl;

}

void MikeOrdersAtPrice::eraseall()
{
	buyLimitAmount = 0;
	buyStopAmount = 0;
	sellLimitAmount = 0;
	sellStopAmount = 0;
}



