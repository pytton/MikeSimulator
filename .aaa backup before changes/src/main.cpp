/*

SITUATION:

class MikeSimulator
{
public:

Control control;		// (MikeSimulator * (this));
Data data;
Display display;

//other stuff here

};

Control.h has function tryout1()

Display.h has member UserInterface * window

UserInterface is derived from FluidInterface

FluidInterface has member Fl_Button *m_btn_down;

*window has member called static void experimental2_cb(Fl_Widget *w, void * p)

experimental2_cb is assigned as callback function for Fl_Button *m_btn_down in the UserInterface constructor (this can be changed)

callback functions for Fl_Button *m_btn_down have to be static!


PROBLEM:

I want the three classes - Control, Data, and Display to easily and freely communicate with each other

I want all members of Display class (including UserInterface and its member WidgetTable) to be able to freely call all functions 
and access all members from Control and Data classes - probably with use of pointers?

I want all members from Control to be able to call all the members and functions inside Display and Data class.

I want all members of Data class to be able to call and access all members of Control and Display class.

For example:

right now I have no problems doing this:

mikesimulator->control.tryout1();

from int main()

but what I want is to be able to assign that

mikesimulator->control.tryout1() - as a call inside the experimental2_cb(Fl_Widget *w, void * p) function which is inside
UserInterface class.

above just an example. I want functions inside Data class to be able to call everything in other two classes too.


*/

//FluidInterface.h and FluidInterface.cxx - these two files are generated by Fluid - DO NOT MODIFY THEM!
//UserInterface.h and UserInterface.cpp - these are the two main files implementing the User interface
//UserInterface class is derived from FluidInterface class
//add/remove elements in the UserInterface class constructor using delete and new

//TODO:

//add a Control class where the main program will run
//add an Algo class which will house all the algos and be accessed by Control - this is where trading decisions are made
//add a Data class which will deal with all the data - at first loaded from a file into some structure database
//at a later point the Data class will be getting a live feed from Interactive Brokers
//connect all the classes with pointers so they know about each other's existance - possibly through just one class

//first algo to write - something very very simple like a stupid scalper without any guards


//#include "UserInterface.h"
//#include "Pointers.h"
//#include "Data.h"
//#include "Control.h"
//#include "Display.h"
#include "MikeSimulator.h"

#include <iostream>
#include <string>

/*

//////////
STRUCTURE:
//////////

ONLY THREE MAIN PARTS (everything else included in on of three parts as a sub-part)

DIPLAY
DATA
CONTROL

Pointers - seperate - stores pointers to all three main parts



FluidInterface - base class for UserInterface - made by Fluid for easy modification. NEVER CHANGE THIS - to make changes - use fluid.exe
UserInterface - main display window derived from FluidInterface
Control????
OrderBook - store all orders here
MarketData - get data from here (live data? stored data? how?)
StreamOfMktSnap - part of MarketData?



Algo - make decisions here (one algo? more algos?)





*/



//int launch(Pointers  * pointers)
//{
//	//UserInterface *window = (UserInterface*)pointers->get_ptr_t_UserInterface();
//	//window->show();
//	//return Fl::run();
//	return 0;
//}



int main()
{
	MikeSimulator * mikesimulator = new MikeSimulator;

//	mikesimulator->GetControl()->tryout1();	//trying out if things work
	
//	mikesimulator->GetControl()->printCurrentAll();

//populate price column with prices:
//	mikesimulator->GetDisplay()->GetWindow()->GetTable()->PopPriceCol(/*mikesimulator->GetDisplay()->GetWindow()->GetTable()*/);


	return Fl::run();
}




